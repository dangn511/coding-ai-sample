import os
import stat
import json
import subprocess
import shutil
from typing import TypedDict, List
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage
from langgraph.graph import StateGraph, START, END
from langchain.chains import ConversationChain
from langchain.memory import ConversationBufferMemory
from git import Repo
from github import Github

f = open('keys.json')
data = json.load(f)

OPENAI_API_KEY = data["openai_key"]
GITHUB_TOKEN = data['github_token']
REPO_LINK = data['repo_link']

class AgentState(TypedDict):
    repo_url: str
    repo_path: str # local path
    task_description: str # MUST be from a file named TASK.md
    generated_code: str
    review_decision: str
    review_feedback: str
    language: str
    extension: str
    coder_history: List
    reviewer_history: List

    # IMPORTANT remember only initialize: repo_url, histories = blank list

# To find: model & finetuning?
llm = ChatOpenAI(api_key= OPENAI_API_KEY,
                 model="gpt-4o-mini")


def retrieve_task(state: AgentState) -> AgentState:
    # If repo_path is empty, this is the first run
    if not state.get("repo_path"):
        clone_dir = "repo_clone"
        state["repo_path"] = clone_dir

        if os.path.exists(clone_dir):
            shutil.rmtree(clone_dir, onerror=on_rm_error)  #TODO: cause issue in Windows


        # clone repo
        clone_cmd = ["git", "clone", state["repo_url"], clone_dir]
        print(f"Cloning repository from {state['repo_url']}...")
        result = subprocess.run(clone_cmd, capture_output=True, text=True)
        if result.returncode != 0:
            raise Exception("Git clone failed: " + result.stderr)
        print("Repository cloned successfully.")

        task_file = os.path.join(clone_dir, "TASK.md")
        if os.path.exists(task_file):
            with open(task_file, "r") as f:
                content = f.read().strip()
            state["task_description"] = content
            # get language requirement
            for line in content.splitlines():
                if line.lower().startswith("language to use:"):
                    state["language"] = line.split(":", 1)[1].strip().lower()

                    language = state.get("language", "python").lower()
                    language_ext = {"python": ".py", "javascript": ".js", "java": ".java", "c++": ".cpp"}
                    if language not in language_ext.keys():
                        # default fallback
                        state['extension'] = ".txt"
                    else:
                        state['extension'] = language_ext[language]

                    print(f"Language specified in TASK.md: {state['language']}, generated code will use the extension {state['extension']}")

                    break
        else:
            print("No task file in directory.")
        print("Task description obtained.")
    else:
        print("Using existing repository clone.")

    return state


def coder(state: AgentState) -> AgentState:

    state = retrieve_task(state)
    language = state.get("language").lower()

    coder_memory = ConversationBufferMemory(memory_key="history", return_messages=True)
    if state.get("coder_history"):
        for msg in state["coder_history"]:
            coder_memory.chat_memory.add_message(msg)

    # MAIN PROMPT FOR CODER
    prompt = f"You are a senior {language} developer. Generate high quality code that completes this task:\n"
    prompt += f"Task description:\n{state['task_description']}\n\n"

    if state.get("review_feedback"):
        prompt += (
            "The previously generated code was rejected. "
            "The reviewer provided the following feedback:\n"
            f"{state['review_feedback']}\n\n"
            "Update the code accordingly to address the issue. "
            "Ensure the code follows best practices, and include in-code comments to explain the code.  "
            "Do not output anything else such as explanation or commentary, other than the code.\n"
        )
    else:
        prompt += (
            "Ensure the code follows best practices, and include in-code comments to explain the code.  "
            "Only output the code, do not output anything else such as commentary or explanation.\n"
        )

    # attempt_counter = 1

    print("Generating code...")
    coder_chain = ConversationChain(llm=llm, memory=coder_memory)
    generated_code = coder_chain.run(prompt)

    state["generated_code"] = generated_code.strip()
    state["coder_history"] = coder_memory.chat_memory.messages

    print("Code generated by coder:")
    print(f"{state['generated_code']}")

    state["review_feedback"] = ""

    # language = state.get("language", "python").lower()
    # language_ext = {"python": ".py", "javascript": ".js", "java": ".java", "c++": ".cpp"}
    # if language not in language_ext.keys():
    #     # default fallback
    #     ext = ".txt"
    # else:
    #     ext = language_ext[language]

    ext = state['extension']
    code_file = os.path.join(state["repo_path"], f"solution{ext}")
    with open(code_file, "w") as f:
        f.write(state["generated_code"])
    print(f"Generated code written to {code_file}.")
    return state


def review_code(state: AgentState) -> AgentState:
    reviewer_memory = ConversationBufferMemory(memory_key="history", return_messages=True)
    if state.get("reviewer_history"):
        for msg in state["reviewer_history"]:
            reviewer_memory.chat_memory.add_message(msg)

    # MAIN PROMPT FOR REVIEWER
    review_prompt = (
        "You are a senior code reviewer. Review the following code and decide if it is correct, can fulfill the task as required, and is ready for submission. "
        "If the code is acceptable, reply with 'APPROVE'. Do not use the word 'reject' in any form if the code is acceptable. "
        "If it is not acceptable, reply with 'REJECT: <feedback>' where <feedback> contains the explanation of the issues with the code and suggestions for improvement. Likewise, do not use the word 'approve' in any form if the code is rejected.\n"
        "Task given:\n"
        f"{state['task_description']}\n"
        "Code:\n"
        f"{state['generated_code']}\n"
    )
    print("Reviewing code...")

    reviewer_chain = ConversationChain(llm=llm, memory=reviewer_memory)
    review_response = reviewer_chain.run(review_prompt)
    # review_response = llm.invoke([HumanMessage(content=review_prompt)]).content.strip()
    review_response_lower = review_response.lower()
    state["reviewer_history"] = reviewer_memory.chat_memory.messages
    print("Feedback from reviewer: ")
    print(f"{review_response_lower}")
    if review_response_lower.startswith("approve"):
        state["review_decision"] = "approve"
        state["review_feedback"] = ""
    elif review_response_lower.startswith("reject:"):
        state["review_decision"] = "reject"
        state["review_feedback"] = review_response[len("reject:"):].strip()
    else:
        state["review_decision"] = "reject"
        state["review_feedback"] = review_response
    print(f"Review decision: {state['review_decision']}")
    if state["review_decision"] == "reject":
        print(f"Feedback from reviewer: {state['review_feedback']}")
    return state


def submit_code(state: AgentState) -> AgentState:
    repo_path = state["repo_path"]
    cwd = os.getcwd()
    os.chdir(repo_path)
    try:
        subprocess.run(["git", "add", "."], check=True)
        subprocess.run(["git", "commit", "-m", "Auto-generated code update"], check=True)
        subprocess.run(["git", "push"], check=True)
        print(f"solution{state['extension']} pushed to GitHub successfully.")
    except subprocess.CalledProcessError as e:
        print("Error during git operations:", e)
    finally:
        os.chdir(cwd)
    return state


#TODO: optional, abort state
def abort_submission(state: AgentState) -> AgentState:
    print("Submission aborted.")
    return state


# workflow = StateGraph(AgentState)
# workflow.add_node("clone_and_generate", coder)
# workflow.add_node("review_code", review_code)
# workflow.add_node("submit_code", submit_code)
# workflow.add_node("abort", abort_submission)
#
# workflow.set_entry_point("clone_and_generate")
#
# workflow.add_edge("clone_and_generate", "review_code")

def decide_next(state: AgentState) -> str:
    # If approved, return "approve".
    # If rejected and feedback exists, return "reject" to retry.
    if state["review_decision"] == "approve":
        return "approve"
    elif state["review_decision"] == "reject":
        # For this example, we assume the coding node should retry.
        return "retry"
    else:
        return "abort"


# # determine whether to retry
# workflow.add_conditional_edges(
#     source = "review_code",
#     path = decide_next,
#     path_map={
#         "approve": "submit_code",
#         "retry": "clone_and_generate",
#         "abort": "abort"
#     }
# )
#
# workflow.add_edge("submit_code", END)
# workflow.add_edge("abort", END)

# a util specifically to fix the rmtree issue on Windows
def on_rm_error(func, path, exc_info):
    os.chmod(path, stat.S_IWRITE)
    func(path)


def run_agent(api_key: str, repo_url: str, language: str = "python") -> AgentState:
    # Set the API key in the environment.
    os.environ["OPENAI_API_KEY"] = api_key
    initial_state: AgentState = {
        "repo_url": repo_url,
        "repo_path": "",
        "task_description": "",
        "generated_code": "",
        "review_decision": "",
        "review_feedback": "",
        "language": language,
        "coder_history": [],
        "reviewer_history": []
    }

    workflow = StateGraph(AgentState)
    workflow.add_node("generate_code", coder)
    workflow.add_node("review_code", review_code)
    workflow.add_node("submit_code", submit_code)
    workflow.add_node("abort", abort_submission)

    workflow.set_entry_point("generate_code")

    workflow.add_edge("generate_code", "review_code")

    # determine whether to retry
    workflow.add_conditional_edges(
        source="review_code",
        path=decide_next,
        path_map={
            "approve": "submit_code",
            "retry": "generate_code",
            "abort": "abort"
        }
    )

    workflow.add_edge("submit_code", END)
    workflow.add_edge("abort", END)


    app = workflow.compile()
    final_state = app.invoke(initial_state)
    return final_state

# initial_state: AgentState = {
#     "repo_url": "https://github.com/dangn511/test-task",
#     "repo_path": "",
#     "task_description": "",
#     "generated_code": "",
#     "review_decision": "",
#     "review_feedback": ""
# }

# app = workflow.compile()
# final_state = app.invoke(initial_state)
# print("\nFinal workflow state:")
# print(final_state)

if __name__ == "__main__":
    run_agent(OPENAI_API_KEY, REPO_LINK)